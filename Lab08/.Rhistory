soren
mean(beta)
install.packages("MASS")
plot(y~x, xlab="Distance to Stream (m)", ylab="DBH (cm)", main="Tree Diameter Based on Distance from Stream")
abline(reg=model1, col="blue") #NOTE: You must run your regression before you can
#add a trend line
data <- read.csv(file.choose(),header=TRUE,na.string=".")
attach(data)
names(data)
data
treatment <- c(Enter treatment 1 header)
control <- c(Enter treatment 2 header)
y1 <- x#subset(data[c(-1,-2,-4,-6,-7)], Creek == "Middle") #the c is to exclude the other variables
y2 <- y#subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
#Descriptive Statistics
mean(x) #gives the mean (average) of x
var(x) #returns the variance of x
sd(x) #returns the standard deviation of x
se <- function(x) {sd(x, na.rm=TRUE/sqrt(length(x)))} #NOTE: DO NOT replace 'x' in this line
#This creates a function that will give you the standard error of x
se
boxplot(y1, y2, xlab="Tree Measurements", ylab="Sizes", names=c("Distance to Stream", "DBH"), main="Tree DBH and Location")
#Paired T-test: use if y1 and y2 are related
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
summary(data) #gives you information about what kind of data these are
y1 <- subset(data[c(-1,-2,-4,-6,-7)], Creek == "Middle") #the c is to exclude the other variables
y2 <- subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
y1 <- subset(data[c(-1,-3,-4,-5,-6,-7, -8, -10)], Creek == "Middle") #the c is to exclude the other variables
y2 <- subset(data[c(-1,-3,-4,-5,-6,-7, -8, -10)], Creek == "South")
boxplot(y1, y2, xlab="Location", ylab="DBH", names=c("Middle", "South"), main="Tree DBH and Location")
t.test(y1, y2, paired=TRUE)
y1 <- Plot.Tree.Density..assuming.8m.radius..area...201m.2..trees.per.square.meter.#the c is to exclude the other variables
y2 <- Average.Tree.DBH#subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
boxplot(y1, y2, xlab="Organism", ylab="Number Observed", names=c("Birds", "Trees"), main="Birds and Trees Observed")
t.test(y1, y2, paired=TRUE)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
y1 <- X..Birds.Observed#the c is to exclude the other variables
y2 <- X..Trees.Observed#subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
boxplot(y1, y2, xlab="Organism", ylab="Number Observed", names=c("Birds", "Trees"), main="Birds and Trees Observed")
boxplot(y1, y2, xlab="Organism", ylab="Number Observed", names=c("Birds", "Trees"), main="Birds and Trees Observed")
t.test(y1, y2, paired=TRUE)
t.test(y1, y2, paired=FALSE, var.equal=FALSE)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data)
y1 <- Species#the c is to exclude the other variables
y2 <- y#subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
y2 <- DBH..cm.#subset(data[c(-1,-2,-4,-6,-7)], Creek == "South")
ox plot
boxplot(y1, y2, xlab="Organism", ylab="Number Observed", names=c("Birds", "Trees"), main="Birds and Trees Observed")
#Paired T-test: use if y1 and y2 are related
t.test(y1, y2, paired=TRUE)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
y1 <- X..Birds.Observed#the c is to exclude the other variables
y2 <- X..Trees.Observed#
boxplot(y1, y2, xlab="Organism", ylab="Number Observed", names=c("Birds", "Trees"), main="Birds and Trees Observed")
t.test(y1, y2, paired=FALSE, var.equal=FALSE)
var.test(y1,y2)
mean_y1 <- mean(y1, na.rm=TRUE)x #replace y1 with the name of the first variable
mean_y2 <- mean(y2, na.rm=TRUE) #replace y1 with the name of the second variable
mean_y1 <- mean(y1, na.rm=TRUE) #replace y1 with the name of the first variable
means <- c(mean_y1, mean_y2)
means
standerrors <- c(se(y1), se(y2))
standerrors
graph <- barplot(means, xlab="Organisms", ylab="Number of Organisms Present", names=c("Birds","Trees"), ylim=c(0, 50), col=c("light blue", "pink"), main=" Number of Birds and Trees")
graph <- barplot(means, xlab="Organisms", ylab="Number of Organisms Present", names=c("Birds","Trees"), ylim=c(0, 20), col=c("light blue", "pink"), main=" Number of Birds and Trees")
arrows(graph, means-standerrors, graph, means+standerrors, code=3, angle = 90, length = 0.1, lwd = 1.3)
arrows(graph, means-standerrors, graph, means+standerrors, code=3, angle = 90, length = 0.1, lwd = 1.3)
standerrors <- c(se(y1), se(y2))
standerrors
arrows(graph, means-standerrors, graph, means+standerrors, code=3, angle = 90, length = 0.1, lwd = 1.3)
standerrors <- c(se(y1), se(y2))
se <- function(x) {sd(x, na.rm=TRUE/sqrt(length(x)))} #NOTE: DO NOT replace 'x' in this line
se
standerrors <- c(se(y1), se(y2))
standerrors
arrows(graph, means-standerrors, graph, means+standerrors, code=3, angle = 90, length = 0.1, lwd = 1.3)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data)
y1 <- Creek == "Middle"
y1 <- subset(data, Creek == "Middle")
y1 <- subset(data, Creek == "Middle")
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
#Create your ow
y1 <- subset(data, Creek == "Middle")
y1 <- Creek
y1 <- factor(Creek, levels = c(1))
y1 <- factor(Creek, levels = 1)
y1 <- factor(Creek)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
y1 <- Middle
y2 <- South
boxplot(y1, y2, xlab="Site", ylab="DBH", names=c("Middle", "South"), main="Tree DBH based on Site")
t.test(y1, y2, paired=FALSE, var.equal=FALSE)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
#making the data easily readable by R
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data)
x <- Distance.to.Stream..m.#creates an abject called x and puts the numbers in it
y <- DBH..cm.
Descriptive Statistics
mean(x) #gives the mean (average) of x
var(x) #returns the variance of x
sd(x) #returns the standard deviation of x
se <- function(x) {sd(x, na.rm=TRUE/sqrt(length(x)))} #NOTE: DO NOT replace 'x' in this line
#This creates a function that will give you the standard error of x
se
plot(y~x, xlab="Distance to Stream (m)", ylab="DBH (cm)", main="Tree Diameter Based on Distance from Stream")
y1 <- x
y2 <- y
t.test(y1, y2, paired=FALSE, var.equal=FALSE)
data <- read.csv(file.choose(), header = TRUE) #Leave () empty
attach(data) #attaches your column headers to the date below them,
names(data) #shows the names of each column in your dataset
head(data) #shows the column names and first 6 rows of the data so you can verify it
data #displays the entire dataset
summary(data) #gives you information about what kind of data these are
x <- DBH
y <- Treated
xy <- data.frame(cbind(x,y))
x <- Treated
y <- DBH
xy <- data.frame(cbind(x,y))
ut <- y[xy$x = 0]
ut <- y[xy$x == 0]
tr <- y[xy$x == 1]
boxplot(ut, tr, xlab="Treated or Not", ylab="DBH (cm)", names=c("Untreated", "Treated"), main="DBH based on Treatement")
t.test(ut, tr, paired=FALSE, var.equal=FALSE)
numOfGuests <- 8
chipBags <- 5
expectedConsumption <- 0.4
expectedConsump <- 0.4
#lab step #3
#These are variables storing the number of guests & how many bags of chips we have
numOfGuests <- 8
chipBags <- 5
#lab step #5: Variable storing how many bags of chips you expect each person to eat
expectedConsump <- 0.4
9 * 0.4
3.6 * 5
5 / 3.6
totalConsump <- (numOfGuests + 1) * expectedConsump
remainingChips <- chipBags * totalConsump
remainingChips <- chipBags / totalConsump
rm(expectedConsumption)
#lab step #3
#These are variables storing the number of guests & how many bags of chips we have
numOfGuests <- 8
chipBags <- 5
#lab step #5: Variable storing how many bags of chips you expect each person to eat
expectedConsump <- 0.4
#lab step #7: totalConsump to calculate how many chip bags you and the guest will eat
#remainingChips is to then see
totalConsump <- (numOfGuests + 1) * expectedConsump
remainingChips <- chipBags / totalConsump
Self <- c(7, 6, 5, 1, 2, 3, 4)
Penny <- c(5, 7, 6, 3, 1, 2, 4)
Jenny <- c(4, 3, 2, 7, 6, 5, 1)
Lenny <- c(1, 7, 3, 4, 6, 5, 2)
Stewie <- c(6, 7, 5, 4, 3, 1, 2)
PennyIV <- Penny[4]
LennyIV <- Lenny[4]
filmRankTable <- (Self, Penny, Jenny, Lenny, Stewie)
filmRankTable <- cbind(Self, Penny, Jenny, Lenny, Stewie)
filmRankTable
str(PennyIV)
str(Penny)
str(filmRankTable)
filmDataFrame <- data.frame(Self, Penny, Jenny, Lenny, Stewie)
filmAsDataFrame <- as.data.frame(Self, Penny, Jenny, Lenny, Stewie)
str(filmDataFrame)
str(filmAsDataFrame)
str(filmAsDataFrame)
str(filmDataFrame)
str(filmDataFrame)
str(filmAsDataFrame)
dim(filmDataFrame)
dim(filmAsDataFrame)
typeof(filmDataFrame)
typeof(filmAsDataFrame)
typeof(filmRankTable)
dim(filmRankTable)
filmAsDataFrame <- as.data.frame(filmRankTable)
str(filmDataFrame)
str(filmAsDataFrame)
dim(filmDataFrame)
dim(filmAsDataFrame)
dim(filmRankTable)
typeof(filmDataFrame)
typeof(filmAsDataFrame)
typeof(filmRankTable)
filmRankTable == filmDataFrame
filmDataFrame == filmAsDataFrame
filmRankTable == filmAsDataFrame
epNames <- c("I", "II", "III", "IV", "V", "VI", "VII")
row.names(filmDataFrame) <- epNames
filmDataFrame
row.names(filmAsDataFrame) <- epNames
row.names(filmRankTable) <- epNames
filmRankTable
filmAsDataFrame
filmRankTable[3,]
filmDataFrame[,4]
filmDataFrame[5,1]
filmDataFrame[2,2]
filmDataFrame[4:6,]
filmDataFrame[(2,5,7),]
filmDataFrame[c(2,5,7),]
filmDataFrame[c(4,6),c(2,3,5)]
swapRank <- filmDataFrame[2,4]
filmDataFrame[5,4]
filmDataFrame[2,4] == filmDataFrame[5,4]
filmDataFrame[2,4] <- filmDataFrame[5,4]
filmDataFrame[5,4] <- swapRank
filmDataFrame
filmRankTable["III", "Penny"]
filmDataFrame["III", "Penny"]
swapRank <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank
filmDataFrame
swapRank3 <- filmDataFrame$Lenny[2]
swapRank2 <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank2
filmDataFrame$Lenny[2] <- filmDataFrame$Lenny[5]
filmDataFrame$Lenny[5] <- swapRank3
filmDataFrame
swapRank3 <- filmDataFrame$Lenny[2]
filmDataFrame$Lenny[2] <- filmDataFrame$Lenny[5]
filmDataFrame$Lenny[5] <- swapRank3
filmDataFrame
swapRank2 <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank2
filmDataFrame
swapRank <- filmDataFrame[2,4]
filmDataFrame[2,4] <- filmDataFrame[5,4]
filmDataFrame[5,4] <- swapRank
filmDataFrame <- data.frame(Self, Penny, Jenny, Lenny, Stewie)
swapRank <- filmDataFrame[2,4]
filmDataFrame[2,4] <- filmDataFrame[5,4]
filmDataFrame[5,4] <- swapRank
filmAsDataFrame
swapRank2 <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank2
filmDataFrame
#PART II
#lab step #8
#vectors containing every persons rankings of the films, with the first element corresponding to Episode I and so on
Self <- c(7, 6, 5, 1, 2, 3, 4)
Penny <- c(5, 7, 6, 3, 1, 2, 4)
Jenny <- c(4, 3, 2, 7, 6, 5, 1)
Lenny <- c(1, 7, 3, 4, 6, 5, 2)
Stewie <- c(6, 7, 5, 4, 3, 1, 2)
#lab step #9
#variables that store Penny and Lenny's ranking of the 4th Episode
PennyIV <- Penny[4]
LennyIV <- Lenny[4]
#lab step #10
#Concatenating all of the rankings into filmRankTable
filmRankTable <- cbind(Self, Penny, Jenny, Lenny, Stewie)
#lab step #11
#This is to see the structure of the following variables and data object
str(PennyIV)
str(Penny)
str(filmRankTable)
#The structure for PennyIV and Penny is num, for filmRankTable there are multiple results
#It says the following:
#num [1:7, 1:5] 7 6 5 1 2 3 4 5 7 6 ...
#- attr(*, "dimnames")=List of 2
#..$ : NULL
#..$ : chr [1:5] "Self" "Penny" "Jenny" "Lenny"
#The NULL is due to not having names for the rows, but the columns have names of type chr
filmDataFrame <- data.frame(Self, Penny, Jenny, Lenny, Stewie)
filmAsDataFrame <- as.data.frame(filmRankTable)
str(filmDataFrame)
str(filmAsDataFrame)
dim(filmDataFrame)
dim(filmAsDataFrame)
dim(filmRankTable)
typeof(filmDataFrame)
typeof(filmAsDataFrame)
typeof(filmRankTable)
#When using typeof() both of the data frames are lists, but the cbind matrix gives you "double"
#dimensions simply provides you with the number of rows and then columns which in every case is 7 5
#structure for all of these says num
filmRankTable == filmDataFrame
filmDataFrame == filmAsDataFrame
filmRankTable == filmAsDataFrame
# == confirms that the values are the same throughout the matrix and the data frames
# All values are listed as TRUE
#lab step #14
#We are making a vector of the Episode names
epNames <- c("I", "II", "III", "IV", "V", "VI", "VII")
#Now we can add this to the data frames
row.names(filmDataFrame) <- epNames
row.names(filmAsDataFrame) <- epNames
row.names(filmRankTable) <- epNames
#Accessing elements of matrices and data frames
#step 16
filmRankTable[3,]
#step 17
filmDataFrame[,4]
#step 18
filmDataFrame[5,1]
#step 19
filmDataFrame[2,2]
#step 20
filmDataFrame[4:6,]
#step 21 -- accessing specific rows
filmDataFrame[c(2,5,7),]
#step 22 -- accessing specific rows and columns
filmDataFrame[c(4,6),c(2,3,5)]
swapRank <- filmDataFrame[2,4]
filmDataFrame[2,4] <- filmDataFrame[5,4]
filmDataFrame[5,4] <- swapRank
filmDataFrame
swapRank2 <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank2
filmDataFrame
swapRank3 <- filmDataFrame$Lenny[2]
filmDataFrame$Lenny[2] <- filmDataFrame$Lenny[5]
filmDataFrame$Lenny[5] <- swapRank3
filmDataFrame
swapRank2 <- filmDataFrame["V", "Lenny"]
filmDataFrame["V", "Lenny"] <- filmDataFrame["II", "Lenny"]
filmDataFrame["II", "Lenny"] <- swapRank2
filmDataFrame
swapRank3 <- filmDataFrame$Lenny[2]
filmDataFrame$Lenny[2] <- filmDataFrame$Lenny[5]
filmDataFrame$Lenny[5] <- swapRank3
filmDataFrame
filteredfst<-read.table(file.choose(), header=T)
hist(filteredfst)
hist(filteredfst$WEIGHTED_FST)
hist(filteredfst$WEIGHTED_FST, breaks = 100)
hist(filteredfst$WEIGHTED_FST, breaks = 1000)
hist(filteredfst$WEIGHTED_FST, breaks = 100)
mean(filteredfst$WEIGHTED_FST)
hist(filteredfst$WEIGHTED_FST, breaks = 100, xlim = c(0.8,1))
hist(filteredfst$WEIGHTED_FST, breaks = 200, xlim = c(0.8,1))
hypotenuse()
hypotenuse <- function( a = 1, b = 1) {
return(sqrt(a**2 + b**2))
}
hypotenuse
hypotenuse()
hypotenuse(,4)
hypotenuse( b = 4)
4**2
4^2
logGrowth <- function(iSize = 100, numberOfGens = 20, K = 500, r = 1.5) {
#Warning for negative arguments where not possible
if(iSize < 0) {
print("ERROR: Initial Population MUST be 0 or greater!")
}
if(numberOfGens < 0) {
print("ERROR: Number of Generations MUST be 0 or greater!")
}
if(K < 0) {
print("ERROR: Carrying Capacity MUST be 0 or greater!")
}
#First lets create a vector n that will hold our abundance values
#The first value will be the initial size of the population
n <- rep(0, numberOfGens)
n[1] <- iSize
#Now we can loop through and calculate each value
for(t in seq(2,numberOfGens)) {
n[t] <- n[t-1] + ( r * n[t-1] * (K - n[t-1])/K )
}
#We can make a y axis with a sequence from 1 to the number of Gens
#we print a plot and return the final abundances
timeGen <- seq(1,numberOfGens)
finalPlot <- plot(timeGen, n, xlab = "Generations", ylab = "Abundances")
return(n)
}
logGrowth(1000, 30, 4000, 1.5)
print(logGrowth(10000, 30, 40000, 1.23))
print(logGrowth(1000, 30, 40000, .823))
print(logGrowth(1000, 20, 40000, .823))
print(logGrowth(1000, 20, 45000, .823))
print(logGrowth(1000, 20, 48000, .823))
write.csv(myData, file = "myData.csv")
myData <- logGrowth(1000, 20, 48000, .823)
write.csv(myData, file = "myData.csv")
setwd("/Users/subi/Desktop/CompBioLabsAndAssignments/Lab08")
myData <- logGrowth(1000, 20, 48000, .823)
write.csv(myData, file = "myData.csv")
write.csv(myData, file = "myData.csv", col.names = TRUE)
write.table(myData, file = "myData.csv", col.names = TRUE)
write.csv(myData, file = "myData.csv")
write.csv(myData, file = "myData.csv", row.names = FALSE)
write.csv(myData, file = "myData.csv")
logGrowth <- function(iSize = 100, numberOfGens = 20, K = 500, r = 1.5) {
#Warning for negative arguments where not possible
if(iSize < 0) {
print("ERROR: Initial Population MUST be 0 or greater!")
}
if(numberOfGens < 0) {
print("ERROR: Number of Generations MUST be 0 or greater!")
}
if(K < 0) {
print("ERROR: Carrying Capacity MUST be 0 or greater!")
}
#First lets create a vector n that will hold our abundance values
#The first value will be the initial size of the population
n <- rep(0, numberOfGens)
n[1] <- iSize
#Now we can loop through and calculate each value
for(t in seq(2,numberOfGens)) {
n[t] <- n[t-1] + ( r * n[t-1] * (K - n[t-1])/K )
}
#We can make a y axis with a sequence from 1 to the number of Gens
#we print a plot and return the final abundances
timeGen <- seq(1,numberOfGens)
finalPlot <- plot(timeGen, n, xlab = "Generations", ylab = "Abundances")
write.csv(myData, file = "myData.csv")
return(n)
}
#example of the function being called
print(logGrowth(1000, 20, 48000, .823))
setwd("/Users/subi/Desktop/CompBioLabsAndAssignments/Lab08")
myData <- logGrowth(1000, 20, 48000, .823)
logGrowth <- function(iSize = 100, numberOfGens = 20, K = 500, r = 1.5) {
#Warning for negative arguments where not possible
if(iSize < 0) {
print("ERROR: Initial Population MUST be 0 or greater!")
}
if(numberOfGens < 0) {
print("ERROR: Number of Generations MUST be 0 or greater!")
}
if(K < 0) {
print("ERROR: Carrying Capacity MUST be 0 or greater!")
}
#First lets create a vector n that will hold our abundance values
#The first value will be the initial size of the population
n <- rep(0, numberOfGens)
n[1] <- iSize
#Now we can loop through and calculate each value
for(t in seq(2,numberOfGens)) {
n[t] <- n[t-1] + ( r * n[t-1] * (K - n[t-1])/K )
}
#We can make a y axis with a sequence from 1 to the number of Gens
#we print a plot and return the final abundances
timeGen <- seq(1,numberOfGens)
finalPlot <- plot(timeGen, n, xlab = "Generations", ylab = "Abundances")
write.csv(myData, file = "myData.csv", col.names = c("Generations", "Abundances"))
return(n)
}
#example of the function being called
print(logGrowth(1000, 20, 48000, .823))
setwd("/Users/subi/Desktop/CompBioLabsAndAssignments/Lab08")
myData <- logGrowth(1000, 20, 48000, .823)
